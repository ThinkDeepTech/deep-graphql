<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<!-- TODO: Different method types needed? Not just post, get, etc... -->

<dom-module id="deep-graphql">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <iron-ajax
      id="service"
      url="[[url]]"
      auto="[[auto]]"
      headers="[[headers]]"
      handle-as="json"
      params="[[__query(queryObject)]]"
      on-response="__formatData"
      reject-with-request
      with-auth
      bubbles
    ></iron-ajax>

  </template>

  <script>
    /**
     * `deep-graphql`
     * Polymer integration with GraphQL
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
     Polymer({
       is: 'deep-graphql',
       properties: {
         /* Graphql data interface corresponding to { data: {...} } */
         data: {
           type: Object,
           value() {
             return {};
           },
           notify: true
         },
         // TODO: Better name for this concept.
         /* Graphql query object. The json object structure to hydrate */
         queryObject: {
           type: Object,
           value() {
             return {};
           }
         },
         /* Graphql service url */
         url: {
           type: String,
           value: '/graphql'
         },
         /* Request headers. */
         headers: Object,
         /* Pass-through to iron-ajax. Automatically triggers requests. */
         auto: {
           type: Boolean,
           value: false
         }
       },
       /**
        * Run query against the GraphQL service.
        * @param {Object} query - GraphQL query.
        * @return {Promise} - Resolves upon completion of the query with the data
        * object.
        */
       query(query = this.query) {
         this.$.service.params = this.__formatQuery(query);
         return this.$.service.generateRequest().completes.then(({response}) => {
           const data = response ? response : {};
           this.set('data', data);
         }, (err) => {
           console.warn(`${this.localName}: GraphQL request failed for query: '${query}'.
            Data will default to {}`);
           this.set('data', {});
         }).then(() => {
           return this.get('data');
         });
       },
       /**
        * Format the user-defined query such that it conforms to GraphQL query
        * syntax.
        * @private
        * @param {Object} data - The object structure to hydrate.
        * @return {Object} - Formatted query or an empty object.
        */
       __query(data) {
         if (!Object.keys(data || {}).length) return {};
         return {query: this.__buildQuery(data)};
       },
       /**
        * Recursively build the query from object to construct query.
        * @private
        * @param {*} subject - Primitive type instance used to determine whether
        * it's needed in the query.
        * @return {String} - The relevant query result.
        */
       __buildQuery(subject) {
         // TODO Attempt DP implementation to gain experience with that. Execution speed
         // wont increase because of recursive subproblems not overlapping but would still
         // be awesome.
          if (typeof subject !== 'object') {
            return '';
          } else {
            let query = '';
            // An array is also considered an object using typeof
            if (Array.isArray(subject)) {
              if (subject.length) {
                // Grab fields from an arbitrary entry
                query = query.concat(this.__buildQuery(subject[0]));
              }
            } else {
              query = query.concat('{ ');
              for (const field in subject) {
                if (subject.hasOwnProperty(field)) {
                  query =
                    query.concat(` ${field} `).concat(this.__buildQuery(subject[field]));
                }
              }
              query = query.concat(' }');
            }
            return query;
          }
       },
       /**
        * Format the data for exposure through the public interface.
        * @private
        * @param {Event} e
        */
       __formatData(e) {
         if(!e || !e.detail || !e.detail.response) return;
         this.data = e.detail.response.data;
       }
     });
  </script>
</dom-module>
